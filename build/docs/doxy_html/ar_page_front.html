<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Universal Scene Description: Ar: Asset Resolution</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="usd_style.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="https://openusd.org/images/USDIcon.ico"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add warning banner to top of page if current page isn't the release version -->
<script>
function AddWarningBanner() 
{
  // Get current URL
  const loc = new URL(location.href);
  // Look for URL of the format "<USD hostname>/<version|dev|release>/api/<file.html>"
  // NOTE: If versioning approach ever changes, this will need updating
  var apiIndex = loc.pathname.indexOf("/api/");
  if (apiIndex >= 0) {
    // Truncate "/api/..." off path to get preceding path and "/" index
    var truncString = loc.pathname.slice(0,apiIndex);
    // Get index of first "/" before "/api/"
    var preApiIndex = truncString.lastIndexOf("/");
    var verString = truncString.slice(preApiIndex + 1);
    // if the current page isn't the release version, add a warning banner 
    if (verString !== "release") {
      // Create alternate "release" URL for page
      // NOTE: This won't always be a valid URL, e.g. if dev release has a brand new page
      var relURL = loc.pathname.substring(0,preApiIndex) + "/release" + loc.pathname.substring(apiIndex);
      var banner = document.createElement("div");
      banner.className = "non_release_version_warning";
      if (verString === "dev") {
        banner.innerHTML = "This document is for a version of USD that is under development. See <a href='" + relURL + "'>this page</a> for the current release.";
      } else {
        // For now, we assume any other string is an older version string
        banner.innerHTML = "This document is for an older version of USD. See <a href='" + relURL + "'>this page</a> for the current release.";
      }
      document.body.insertBefore(banner,document.body.childNodes[0]);
    }
  }
} 
</script>
</head>
<body onload="AddWarningBanner()">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="USDLogoDocs.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ar_page_front.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Ar: Asset Resolution </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ar_overview"></a>
Overview</h1>
<p>The Ar (Asset Resolution) library is responsible for querying, reading, and writing asset data. It provides several interfaces that allow USD to access an asset without knowing how that asset is physically stored.</p>
<p>Ar ships with implementations based on a traditional filesystem. However, users can provide custom implementations to integrate their own asset storage system and behaviors with USD. For example, a user might have an asset system that stores assets in a database and uses special identifiers to address those assets. That user could create a custom implementation of the <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> interface that interprets those identifiers and a custom implementation of the <a class="el" href="class_ar_asset.html" title="Interface for accessing the contents of an asset.">ArAsset</a> interface that reads data straight from the database. This would allow the user to use those identifiers for references, payloads, and sublayer composition arcs and other places throughout USD.</p>
<h1><a class="anchor" id="ar_resolver"></a>
ArResolver</h1>
<p><a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> is the central interface for asset operations in Ar. Clients can implement subclasses of this interface to customize behaviors for their asset system.</p>
<p>Ar manages a set of <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> subclasses for handling different asset paths, which are described below. These subclasses are discovered and instantiated via the plugin system and managed internally by Ar. Instead of using these subclasses directly, clients just use a single resolver that is accessed by calling <a class="el" href="ar_2resolver_8h.html#ab0913ebfd579684add6b59b44983a633" title="Returns the configured asset resolver.">ArGetResolver</a>. When methods are called on this resolver, Ar will determine the appropriate subclass for handling the given input paths and forward the call to that subclass.</p>
<h2><a class="anchor" id="ar_primary_resolver"></a>
Primary Resolver</h2>
<p>The primary resolver is the <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> subclass that Ar uses to handle all asset paths that are not handled by the other resolvers described below.</p>
<p>To create a custom primary resolver:</p>
<ul>
<li>Implement an <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> subclass <div class="fragment"><div class="line"><span class="keyword">class </span>CustomResolver : <span class="keyword">public</span> <a class="code" href="class_ar_resolver.html">ArResolver</a> {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --></li>
<li>Use <a class="el" href="define_resolver_8h.html#a57f69ee744b21cbf5d4b2e13215117ba" title="Performs registrations required for the specified resolver class to be discovered by Ar&#39;s plugin mech...">AR_DEFINE_RESOLVER</a> to define the subclass as a resolver <div class="fragment"><div class="line"><span class="preprocessor"># In the custom resolver&#39;s .cpp file</span></div><div class="line"><span class="preprocessor">AR_DEFINE_RESOLVER(CustomResolver, ArResolver);</span></div></div><!-- fragment --></li>
<li>Declare the subclass in the plugin's plugInfo.json file. See <a class="el" href="class_plug_registry.html">PlugRegistry</a> for more details. <div class="fragment"><div class="line"># plugInfo.json</div><div class="line">{</div><div class="line">    &quot;Plugins&quot;: [</div><div class="line">        {</div><div class="line">            &quot;Info&quot;: {</div><div class="line">                &quot;Types&quot; : {</div><div class="line">                    &quot;CustomResolver&quot; : {</div><div class="line">                        &quot;bases&quot;: [ &quot;ArResolver&quot; ]</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            },</div><div class="line">            ...</div><div class="line">        }</div><div class="line">    ]</div><div class="line"></div><div class="line">}</div></div><!-- fragment --></li>
<li>Ensure that the resolver plugin is located where the plugin system can find it.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Ar does not support custom resolvers implemented in Python to avoid performance issues, especially for multi-threaded consumers.</dd></dl>
<p>At runtime Ar will query the plugin system to discover any classes that have <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> or another subclass of <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> declared as a base type, then instantiate that class when needed. Keep in mind that the class may be constructed at any time; at a minimum, the class will be constructed during the first call to <a class="el" href="ar_2resolver_8h.html#ab0913ebfd579684add6b59b44983a633">ArGetResolver</a>.</p>
<p>If no custom resolver is found, Ar will use <a class="el" href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided.">ArDefaultResolver</a> as the primary resolver. This resolver assumes all asset paths it encounters are filesystem paths. <a class="el" href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided.">ArDefaultResolver</a> also performs simple search path-based resolution that will search for an asset in a specified list of directories. See documentation on <a class="el" href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided.">ArDefaultResolver</a> for more information on configuring this behavior.</p>
<h2><a class="anchor" id="ar_uri_resolvers"></a>
URI/IRI Resolvers</h2>
<p>URI/IRI resolvers are <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> subclasses that are associated with particular resource identifier schemes.</p>
<dl class="section note"><dt>Note</dt><dd>IRIs are URIs which support unicode characters in certain components of the identifier. All URIs are IRIs, and compliant IRIs can be idempotently converted to URIs through percent encoding.</dd></dl>
<p>When Ar encounters an asset path or resolved path of the form "&lt;scheme&gt;:...", it will check if any <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> subclasses have been registered for the scheme. If so, it will dispatch the path to that subclass for handling. If not, it will dispatch the path to the primary resolver for handling. Schemes should adhere to the URI/IRI specification and are ASCII only.</p>
<p>For example, if there were an HTTPResolver subclass of <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> that was registered to handle the "http" scheme. If the following was called:</p>
<div class="fragment"><div class="line"><a class="code" href="ar_2resolver_8h.html#ab0913ebfd579684add6b59b44983a633">ArGetResolver</a>().<a class="code" href="class_ar_resolver.html#a1b824f00c46b2a5001f492698fd8f5c1">Resolve</a>(<span class="stringliteral">&quot;http://mynetwork/model.usd&quot;</span>)</div></div><!-- fragment --><p>Ar would inspect the given path, find the "http" scheme and determine that "http" was associated with HTTPResolver. Ar would create an instance of the HTTPResolver (if one had not already been created), then call HTTPResolver::Resolve on that instance with the given path.</p>
<p>To create a URI/IRI resolver:</p>
<ul>
<li>Implement a subclass of <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> as described in the <a class="el" href="ar_page_front.html#ar_primary_resolver">Primary Resolver</a> section above.</li>
<li>In the entry for the subclass in the plugin's plugInfo.json file, add a "uriSchemes" key with a list of schemes associated with the resolver. <div class="fragment"><div class="line">{</div><div class="line">    &quot;Plugins&quot;: [</div><div class="line">        {</div><div class="line">            &quot;Info&quot;: {</div><div class="line">                &quot;Types&quot;: {</div><div class="line">                    &quot;HTTPResolver&quot;: {</div><div class="line">                        &quot;bases&quot;: [&quot;ArResolver&quot;],</div><div class="line">                        &quot;uriSchemes&quot;: [&quot;http&quot;, &quot;https&quot;]</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            },</div><div class="line">            ...</div><div class="line">        }</div><div class="line">    ]</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
<p><code>uriSchemes</code> may be used to register resolvers which support non-percent encoded IRIs. Unicode characters in asset path strings should be UTF-8 encoded.</p>
<p>Resolvers are ultimately responsible for validation, normalization, and parsing of asset paths. USD does not attempt to validate or parse resource identifiers beyond what's needed for dispatching via 'scheme'. When a resolver is working with a protocol that strictly requires percent-encoded URIs, it's acceptable for the resolver to accept UTF-8 encoded IRIs and internally handle percent encoding.</p>
<h1><a class="anchor" id="ar_resolution"></a>
Asset Path Resolution</h1>
<p>An asset path is a string that describes the location of an asset in a user's system. These paths are used extensively throughout USD; for example, asset paths are used to specify sublayers, references, and payloads in scene description.</p>
<p>One of <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a>'s primary responsibilities is to resolve an input asset path by determining if an asset exists at the given path and, if so, returning a resolved path that may be used by other <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> API and in other parts of the system. This is done via calls to <a class="el" href="class_ar_resolver.html#a1b824f00c46b2a5001f492698fd8f5c1" title="Returns the resolved path for the asset identified by the given assetPath if it exists.">ArResolver::Resolve</a>. This process allows <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> subclasses to apply custom logic to determine the actual asset that a logical asset path refers to.</p>
<p>For example, the filesystem-based <a class="el" href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided.">ArDefaultResolver</a> implements search-path logic in its asset path resolution. When <a class="el" href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided.">ArDefaultResolver</a> is given a relative filesystem asset path to resolve like "Foo/Bar/Baz.usd", it will look for that file relative to the current working directory, then relative to a set of search paths. Once it finds an existing file, it will return the absolute path to that file as the resolved path.</p>
<p>For more details, see:</p><ul>
<li><a class="el" href="class_ar_resolver.html#ArResolver_resolution">Path Resolution Operations</a></li>
<li><a class="el" href="class_ar_resolver.html#ArResolver_implementation">Implementation</a></li>
</ul>
<h1><a class="anchor" id="ar_resolver_contexts"></a>
Resolver Contexts</h1>
<p>A resolver context is an object that stores configuration or other information that can be used by a resolver to guide path resolution and other operations. Resolver contexts can be bound within blocks of code to affect resolver operations within that scope via an <a class="el" href="class_ar_resolver_context_binder.html" title="Helper object for managing the binding and unbinding of ArResolverContext objects with the asset reso...">ArResolverContextBinder</a>. <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> uses this functionality heavily to allow different stages to resolve asset paths differently.</p>
<p>For example, <a class="el" href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided.">ArDefaultResolver</a> has a context object <a class="el" href="class_ar_default_resolver_context.html" title="Resolver context object that specifies a search path to use during asset resolution.">ArDefaultResolverContext</a> that contains a set of search paths for use during resolution that prepend <a class="el" href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided.">ArDefaultResolver</a>'s list of global search paths. A client might use this to set up stages that look in different locations for assets:</p>
<div class="fragment"><div class="line"><span class="comment">// Configure ArDefaultResolver&#39;s global search paths.</span></div><div class="line"><a class="code" href="class_ar_default_resolver.html#aa800e0f25ecd6949b00477243ce0c6a7">ArDefaultResolver::SetDefaultSearchPath</a>({<span class="stringliteral">&quot;/Global/assets&quot;</span>});</div><div class="line"></div><div class="line"><span class="comment">// Create a resolver context with an additional search path and</span></div><div class="line"><span class="comment">// use it for opening the UsdStage for ShotA.usd.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If ShotA.usd contains an asset path like &quot;Foo/Bar/Baz.usd&quot;,</span></div><div class="line"><span class="comment">// ArDefaultResolver will search for this file at: </span></div><div class="line"><span class="comment">//  - &lt;current working dir&gt;/Foo/Bar/Baz.usd</span></div><div class="line"><span class="comment">//  - /ShotA/assets/Foo/Bar/Baz.usd</span></div><div class="line"><span class="comment">//  - /Global/assets/Foo/Bar/Baz.usd</span></div><div class="line"><a class="code" href="class_ar_default_resolver_context.html">ArDefaultResolverContext</a> shotACtx({<span class="stringliteral">&quot;/ShotA/assets&quot;</span>})</div><div class="line">UsdStageRefPtr shotA = <a class="code" href="class_usd_stage.html#abd74eb9ec70572c2dadaf4cd07144380">UsdStage::Open</a>(<span class="stringliteral">&quot;ShotA.usd&quot;</span>, shotACtx);</div><div class="line"></div><div class="line"><span class="comment">// Create a resolver context with an additional search path and</span></div><div class="line"><span class="comment">// use it for opening the UsdStage for ShotB.usd.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// If ShotB.usd contains the same asset path as above in ShotA,</span></div><div class="line"><span class="comment">// ArDefaultResolver will search for this file at: </span></div><div class="line"><span class="comment">//  - &lt;current working dir&gt;/Foo/Bar/Baz.usd</span></div><div class="line"><span class="comment">//  - /ShotB/assets/Foo/Bar/Baz.usd</span></div><div class="line"><span class="comment">//  - /Global/assets/Foo/Bar/Baz.usd</span></div><div class="line"><a class="code" href="class_ar_default_resolver_context.html">ArDefaultResolverContext</a> shotBCtx({<span class="stringliteral">&quot;/ShotB/assets&quot;</span>})</div><div class="line">UsdStageRefPtr shotB = <a class="code" href="class_usd_stage.html#abd74eb9ec70572c2dadaf4cd07144380">UsdStage::Open</a>(<span class="stringliteral">&quot;ShotB.usd&quot;</span>, shotBCtx);</div></div><!-- fragment --><p>It's important to note that any information in a resolver context that is used during path resolution should be factored into the resulting resolved path. This is because resolved paths may be passed to downstream clients or external libraries that will not (or can not) have a context object bound when the resolved path is used to open an asset. Put another way: a resolved path should be usable by downstream clients that do not have a resolver context bound.</p>
<p>Context binding and unbinding are thread-specific. If you bind a context in a thread, that binding will only be visible to that thread. If you want to use the same context to resolve asset paths in multiple threads, youâ€™ll need to bind the context in multiple threads.</p>
<p>For more details, see:</p>
<ul>
<li><a class="el" href="class_ar_resolver_context.html" title="An asset resolver context allows clients to provide additional data to the resolver for use during re...">ArResolverContext</a></li>
<li><a class="el" href="class_ar_resolver_context_binder.html" title="Helper object for managing the binding and unbinding of ArResolverContext objects with the asset reso...">ArResolverContextBinder</a></li>
<li><a class="el" href="class_ar_resolver.html#ArResolver_context">Asset Resolver Context Operations</a></li>
<li><a class="el" href="class_ar_resolver.html#ArResolver_contextImplementation">Context Operations Implementation</a></li>
</ul>
<h1><a class="anchor" id="ar_resolver_scoped_cache"></a>
Resolver Scoped Caches</h1>
<p>A resolver scoped cache is a cache of asset resolution results that is active during a given block of code. Clients can activate a scoped cache by using an <a class="el" href="class_ar_resolver_scoped_cache.html" title="Helper object for managing asset resolver cache scopes.">ArResolverScopedCache</a> object.</p>
<p>Resolving asset paths may be expensive and a <a class="el" href="class_usd_stage.html" title="The outermost container for scene description, which owns and presents composed prims as a scenegraph...">UsdStage</a> may need to resolve hundreds to thousands of asset paths (or more) depending on the complexity of the scene, many of which may be repeated. A scoped cache helps to minimize that expense. A scoped cache also ensures that resolving a given asset path multiple times returns the same result, which is important for consistency and correctness.</p>
<p>Ar provides default scoped cache behaviors for all <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> subclasses. However, this default behavior is very basic. Subclasses may provide their own scoped cache implementations that can take advantage of implementation details of their underlying asset system to maximize efficiency. For such cases Ar provides an <a class="el" href="class_ar_thread_local_scoped_cache.html" title="Utility class for custom resolver implementations.">ArThreadLocalScopedCache</a> utility class to help with this.</p>
<p>For more details, see:</p>
<ul>
<li><a class="el" href="class_ar_resolver.html#ArResolver_scopedCache">Scoped Resolution Cache</a></li>
<li><a class="el" href="class_ar_resolver.html#ArResolver_scopedCacheImplementation">Scoped Resolution Cache Implementation</a></li>
</ul>
<h1><a class="anchor" id="ar_paths"></a>
Asset Paths and Resolved Paths</h1>
<p>In general, Ar does not impose any requirements or restrictions on the format of an asset path or resolved path. Users are free to use whatever path syntax they want as long as they are supported by their underlying resolver implementations. For example, the filesystem-based <a class="el" href="class_ar_default_resolver.html" title="Default asset resolution implementation used when no plugin implementation is provided.">ArDefaultResolver</a> simply uses filesystem paths, but other implementations might use special URIs or database identifiers.</p>
<p>Ar reserves trailing bracket-enclosed paths as syntax for package-relative asset paths. For example, paths like:</p>
<ul>
<li>"/foo/baz.usdz[file.usd]"</li>
<li>"my-uri://foo/baz.usdz[file.usd]"</li>
</ul>
<p>will be recognized by Ar as a package-relative asset path and will be split so that <a class="el" href="class_ar_resolver.html" title="Interface for the asset resolution system.">ArResolver</a> subclasses will only see the path "/foo/baz.usdz" or "my-uri://foo/baz.usdz". For more details, see <a class="el" href="package_utils_8h.html#Ar_packagePaths">Package Relative Paths</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">&copy; Copyright 2023, Pixar Animation Studios. Generated on Mon Nov 20 2023 16:06:57 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>